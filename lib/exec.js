// Generated by CoffeeScript 1.6.3
var actions, bin, colors, doAction, hint, input, inspector, keypress, kid, kids, normalize, program, prompt, readFileSync, refresh, run, shutdown, spawn, webPort, _ref,
  __slice = [].slice;

readFileSync = require('fs').readFileSync;

normalize = require('path').normalize;

spawn = require('child_process').spawn;

colors = require('colors');

program = require('commander');

keypress = require('keypress');

keypress(process.stdin);

program.version(JSON.parse(readFileSync(__dirname + '/../package.json'), 'utf8').version);

program.option('-i, --inspector', 'Start node-inspector.');

program.option('-w, --web-port [webPort]', 'Node inspector @ alternate port.');

_ref = program.parse(process.argv), inspector = _ref.inspector, webPort = _ref.webPort;

kids = [];

if (inspector) {
  bin = normalize(__dirname + '/../node_modules/.bin/node-inspector');
  kids.push(kid = spawn(bin, [
    "--web-port=" + (((function() {
      try {
        return parseInt(webPort);
      } catch (_error) {}
    })()) || 8080)
  ]));
  kid.stdout.on('data', function(chunk) {
    return refresh(chunk.toString());
  });
  kid.stderr.on('data', function(chunk) {
    return refresh(chunk.toString(), 'stderr');
  });
}

prompt = '> ';

input = '';

hint = '';

actions = {
  'node-debug': {
    args: '<port> <script>'
  },
  'coffee-debug': {
    args: '<port> <script>'
  }
};

refresh = function(output, stream) {
  if (output != null) {
    switch (stream) {
      case 'stderr':
        process.stdout.write(output.red);
        break;
      default:
        process.stdout.write(output);
    }
  }
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  process.stdout.write(prompt + input + hint);
  return process.stdout.cursorTo((prompt + input).length);
};

shutdown = function(code) {
  var _i, _len;
  for (_i = 0, _len = kids.length; _i < _len; _i++) {
    kid = kids[_i];
    kid.kill();
  }
  return process.exit(code);
};

doAction = function() {
  var act, args, _ref1;
  _ref1 = input.split(' '), act = _ref1[0], args = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
  if (input !== '') {
    console.log({
      action: act,
      args: args
    });
  }
  return input = '';
};

run = function() {
  var stdin;
  stdin = process.openStdin();
  process.stdin.setRawMode(true);
  refresh();
  return process.stdin.on('keypress', function(chunk, key) {
    var action, ctrl, matches, meta, name, sequence, shift, _i, _len;
    hint = '';
    try {
      name = key.name, ctrl = key.ctrl, meta = key.meta, shift = key.shift, sequence = key.sequence;
    } catch (_error) {}
    if (ctrl) {
      switch (name) {
        case 'd':
          shutdown(0);
          break;
        case 'c':
          input = '';
          refresh();
      }
      return;
    }
    if (name === 'backspace') {
      input = input.slice(0, -1);
      return refresh();
    }
    if (name === 'tab') {
      matches = [];
      for (action in actions) {
        if (action.match(new RegExp("^" + input))) {
          matches.push(action);
        }
      }
      if (matches.length === 1) {
        input = matches[0];
        hint = ' ' + actions[matches[0]].args.grey;
        return refresh();
      } else {
        console.log();
        for (_i = 0, _len = matches.length; _i < _len; _i++) {
          action = matches[_i];
          console.log(action, actions[action].args.grey);
        }
        return refresh();
      }
    }
    if (name === 'return') {
      process.stdout.write('\n');
      doAction();
      process.stdout.write(prompt + input);
      return;
    }
    if (!chunk) {
      return;
    }
    input += chunk.toString();
    return refresh();
  });
};

run();
