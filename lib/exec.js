// Generated by CoffeeScript 1.6.3
var actions, argsHint, bin, colors, doAction, input, inspector, keypress, kid, kids, lstatSync, normalize, primaryTabComplete, program, prompt, readFileSync, readdirSync, refresh, run, secondaryTabComplete, sep, shutdown, spawn, webPort, _ref, _ref1,
  __slice = [].slice;

_ref = require('fs'), readFileSync = _ref.readFileSync, readdirSync = _ref.readdirSync, lstatSync = _ref.lstatSync;

normalize = require('path').normalize;

spawn = require('child_process').spawn;

sep = require('path').sep;

colors = require('colors');

program = require('commander');

keypress = require('keypress');

keypress(process.stdin);

program.version(JSON.parse(readFileSync(__dirname + '/../package.json'), 'utf8').version);

program.option('-i, --inspector', 'Start node-inspector.');

program.option('-w, --web-port [webPort]', 'Node inspector @ alternate port.');

_ref1 = program.parse(process.argv), inspector = _ref1.inspector, webPort = _ref1.webPort;

kids = [];

if (inspector) {
  bin = normalize(__dirname + '/../node_modules/.bin/node-inspector');
  kids.push(kid = spawn(bin, [
    "--web-port=" + (((function() {
      try {
        return parseInt(webPort);
      } catch (_error) {}
    })()) || 8080)
  ]));
  kid.stdout.on('data', function(chunk) {
    return refresh(chunk.toString());
  });
  kid.stderr.on('data', function(chunk) {
    return refresh(chunk.toString(), 'stderr');
  });
}

prompt = '> ';

input = '';

argsHint = '';

actions = {
  'node-debug': {
    args: '[<port>] <script>',
    secondary: 'pathWalker'
  },
  'coffee-debug': {
    args: '[<port>] <script>',
    secondary: 'pathWalker'
  }
};

primaryTabComplete = function() {
  var action, matches;
  matches = [];
  for (action in actions) {
    if (action.match(new RegExp("^" + input))) {
      matches.push(action);
    }
  }
  if (matches.length === 0) {
    input = '';
    return primaryTabComplete();
  }
  return matches;
};

secondaryTabComplete = function(act) {
  var all, file, files, last, part, parts, path, secondaryType, select, stat, _i, _len;
  try {
    secondaryType = actions[act].secondary;
  } catch (_error) {}
  if (!secondaryType) {
    return [];
  }
  if (secondaryType === 'pathWalker') {
    try {
      all = input.split(' ').pop();
    } catch (_error) {}
    parts = all.split(sep);
    last = parts.pop();
    path = process.cwd() + sep + parts.join(sep) + sep;
    files = readdirSync(path);
    select = files.filter(function(file) {
      return file.match(new RegExp("^" + last));
    });
    if (select.length === 1) {
      input += select[0].slice(last.length);
      file = input.split(' ').pop();
      stat = lstatSync(process.cwd() + sep + file);
      if (stat.isDirectory()) {
        input += sep;
      }
    } else {
      console.log();
      for (_i = 0, _len = select.length; _i < _len; _i++) {
        part = select[_i];
        stat = lstatSync(path + part);
        if (stat.isDirectory()) {
          console.log(part + sep);
        } else {
          console.log(part);
        }
      }
    }
    return [];
  }
};

refresh = function(output, stream) {
  if (output != null) {
    switch (stream) {
      case 'stderr':
        process.stdout.write(output.red);
        break;
      default:
        process.stdout.write(output);
    }
  }
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  process.stdout.write(prompt + input + argsHint);
  return process.stdout.cursorTo((prompt + input).length);
};

shutdown = function(code) {
  var _i, _len;
  for (_i = 0, _len = kids.length; _i < _len; _i++) {
    kid = kids[_i];
    kid.kill();
  }
  return process.exit(code);
};

doAction = function() {
  var act, args, trimmed, _ref2;
  if (input === '') {
    return;
  }
  _ref2 = input.split(' '), act = _ref2[0], args = 2 <= _ref2.length ? __slice.call(_ref2, 1) : [];
  trimmed = args.filter(function(arg) {
    return arg !== '';
  });
  if (act != null) {
    console.log({
      action: act,
      args: trimmed
    });
  }
  return input = '';
};

run = function() {
  var stdin;
  stdin = process.openStdin();
  process.stdin.setRawMode(true);
  refresh();
  return process.stdin.on('keypress', function(chunk, key) {
    var act, action, ctrl, m, matches, meta, name, sequence, shift, _i, _len, _ref2;
    argsHint = '';
    try {
      name = key.name, ctrl = key.ctrl, meta = key.meta, shift = key.shift, sequence = key.sequence;
    } catch (_error) {}
    if (ctrl) {
      switch (name) {
        case 'd':
          shutdown(0);
          break;
        case 'c':
          input = '';
          refresh();
      }
      return;
    }
    if (name === 'backspace') {
      input = input.slice(0, -1);
      return refresh();
    }
    if (name === 'tab') {
      try {
        _ref2 = input.match(/^(.*?)\s/), m = _ref2[0], act = _ref2[1];
      } catch (_error) {}
      if (act != null) {
        matches = secondaryTabComplete(act);
      } else {
        matches = primaryTabComplete();
      }
      if (matches.length === 1) {
        input = matches[0];
        argsHint = ' ' + actions[matches[0]].args.grey;
        return refresh();
      } else {
        console.log();
        for (_i = 0, _len = matches.length; _i < _len; _i++) {
          action = matches[_i];
          console.log(action, actions[action].args.grey);
        }
        return refresh();
      }
    }
    if (name === 'return') {
      process.stdout.write('\n');
      doAction();
      process.stdout.write(prompt + input);
      return;
    }
    if (!chunk) {
      return;
    }
    input += chunk.toString();
    return refresh();
  });
};

run();
