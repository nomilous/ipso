// Generated by CoffeeScript 1.6.3
var dirname, lastInstance, lstatSync, normalize, parallel, readdirSync, sep, underscore, _ref, _ref1;

parallel = require('also').parallel;

_ref = require('path'), normalize = _ref.normalize, sep = _ref.sep, dirname = _ref.dirname;

underscore = require('inflection').underscore;

_ref1 = require('fs'), readdirSync = _ref1.readdirSync, lstatSync = _ref1.lstatSync;

require('colors');

lastInstance = void 0;

module.exports._test = function() {
  return lastInstance;
};

module.exports.create = function(config) {
  var api, local;
  lastInstance = local = {
    dir: config.dir,
    modules: config.modules,
    upperCase: function(string) {
      var char, error;
      try {
        char = string[0].charCodeAt(0);
      } catch (_error) {
        error = _error;
        return false;
      }
      if (char > 64 && char < 91) {
        return true;
      }
      return false;
    },
    recurse: function(name, path, matches) {
      var fd, file, stat, _i, _len, _ref2, _results;
      _ref2 = readdirSync(path);
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        fd = _ref2[_i];
        file = path + sep + fd;
        stat = lstatSync(file);
        if (stat.isDirectory()) {
          local.recurse(name, file, matches);
          continue;
        }
        if (fd.match(new RegExp("^" + name + ".[js|coffee]"))) {
          _results.push(matches.push(dirname(file) + sep + name));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    find: function(name) {
      var matches;
      matches = [];
      try {
        local.recurse(underscore(name), local.dir + sep + 'lib', matches);
      } catch (_error) {}
      try {
        local.recurse(underscore(name), local.dir + sep + 'app', matches);
      } catch (_error) {}
      if (matches.length > 1) {
        throw new Error("ipso: found multiple matches for " + name + ", use ipso.modules");
      }
      return matches[0];
    },
    loadModule: function(name, does) {
      var path;
      if (path = ((function() {
        try {
          return local.modules[name].require;
        } catch (_error) {}
      })())) {
        if (path[0] === '.') {
          path = normalize(local.dir + sep + path);
        }
        return require(path);
      }
      if (!local.upperCase(name)) {
        return require(name);
      }
      if (path = local.find(name)) {
        return require(path);
      }
      console.log('ipso: ' + ("warning: missing module " + name).yellow);
      return {
        $ipso: {
          PENDING: true,
          module: name,
          save: function(path) {
            return console.log("\n#\n#   NonExistantModule.$ipso.save(templateTag, pa/th) \n#   ------------------------------------------------\n#   \n#   Not yet implemented.\n# \n#   * (for never having to write anything twice)\n#   * for cases where ipso detects the injection of a not yet existing module\n#   * can save the newly written stub to ./src/path/ as the \"\"first draft\"\" \n#   * templates from ~/.ipso/templates\n#   * pending `does` to expose access to expectations for a list of functions to create\n#                                                         -----------------------------\n# \n#   \n#             perhaps there's an even slicker way to do it?\n#  \n".green);
          }
        }
      };
    },
    loadModules: function(fnArgsArray, does) {
      var Module, promise;
      return promise = parallel((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = fnArgsArray.length; _i < _len; _i++) {
          Module = fnArgsArray[_i];
          _results.push((function(Module) {
            return function() {
              return does.spectate(Module, local.loadModule(Module, does));
            };
          })(Module));
        }
        return _results;
      })());
    }
  };
  return api = {
    loadModules: local.loadModules
  };
};
