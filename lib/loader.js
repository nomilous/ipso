// Generated by CoffeeScript 1.6.3
var EOL, basename, deferred, dirname, lastInstance, lstatSync, normalize, parallel, pipeline, readdirSync, relative, sep, underscore, _ref, _ref1, _ref2;

_ref = require('also'), deferred = _ref.deferred, parallel = _ref.parallel, pipeline = _ref.pipeline;

_ref1 = require('path'), normalize = _ref1.normalize, sep = _ref1.sep, dirname = _ref1.dirname, basename = _ref1.basename, relative = _ref1.relative;

underscore = require('inflection').underscore;

_ref2 = require('fs'), readdirSync = _ref2.readdirSync, lstatSync = _ref2.lstatSync;

EOL = require('os').EOL;

require('colors');

lastInstance = void 0;

module.exports._test = function() {
  return lastInstance;
};

module.exports.create = function(config) {
  var api, local;
  lastInstance = local = {
    loadModules: function(arrayOfNames, doesInstance) {
      var moduleName, promise;
      return promise = parallel((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arrayOfNames.length; _i < _len; _i++) {
          moduleName = arrayOfNames[_i];
          _results.push((function(moduleName) {
            return function() {
              var nestedPromise;
              return nestedPromise = pipeline([
                function() {
                  return local.loadModule(moduleName, doesInstance);
                }, function(module) {
                  return doesInstance.spectate({
                    name: moduleName,
                    tagged: false
                  }, module);
                }
              ]);
            };
          })(moduleName));
        }
        return _results;
      })());
    },
    loadModulesSync: function(arrayOfNames, doesInstance) {
      var Module, arrayOfModules, moduleName;
      return arrayOfModules = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arrayOfNames.length; _i < _len; _i++) {
          moduleName = arrayOfNames[_i];
          Module = local.loadModuleSync(moduleName, doesInstance);
          _results.push(doesInstance.spectateSync({
            name: moduleName,
            tagged: false
          }, Module));
        }
        return _results;
      })();
    },
    dir: config.dir,
    modules: config.modules,
    upperCase: function(string) {
      var char, error;
      try {
        char = string[0].charCodeAt(0);
      } catch (_error) {
        error = _error;
        return false;
      }
      if (char > 64 && char < 91) {
        return true;
      }
      return false;
    },
    recurse: function(name, path, matches) {
      var fd, file, stat, _i, _len, _ref3, _results;
      _ref3 = readdirSync(path);
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        fd = _ref3[_i];
        file = path + sep + fd;
        stat = lstatSync(file);
        if (stat.isDirectory()) {
          local.recurse(name, file, matches);
          continue;
        }
        if (fd.match(new RegExp("^" + name + ".[js|coffee]"))) {
          _results.push(matches.push(dirname(file) + sep + name));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    find: function(name) {
      var matches;
      matches = [];
      try {
        local.recurse(underscore(name), local.dir + sep + 'lib', matches);
      } catch (_error) {}
      try {
        local.recurse(underscore(name), local.dir + sep + 'app', matches);
      } catch (_error) {}
      if (matches.length > 1) {
        throw new Error("ipso: found multiple matches for " + name + ", use ipso.modules");
      }
      return matches[0];
    },
    save: function(template, name, does) {
      var getLocation;
      getLocation = function() {
        var baseName, fileName, line, lineNrs, m, path, specPath, _i, _len, _ref3, _ref4, _ref5;
        _ref3 = (new Error).stack.split(EOL);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          line = _ref3[_i];
          baseName = void 0;
          try {
            _ref4 = line.match(/.*\((.*?):(.*)/), m = _ref4[0], path = _ref4[1], lineNrs = _ref4[2];
          } catch (_error) {}
          if (path == null) {
            continue;
          }
          fileName = basename(path);
          try {
            _ref5 = fileName.match(/(.*)_spec.[coffee|js]/), m = _ref5[0], baseName = _ref5[1];
          } catch (_error) {}
          if (!baseName) {
            continue;
          }
          specPath = relative(process.cwd(), dirname(path));
          return {
            fileName: fileName,
            baseName: baseName,
            specPath: specPath
          };
        }
      };
      return does.get({
        query: {
          tag: name
        }
      }, function(err, entity) {
        return console.log({
          location: getLocation(),
          lib: '???',
          entity: entity
        });
      });
    },
    loadModule: deferred(function(action, name, does) {
      return does.get({
        query: {
          tag: name
        }
      }, function(error, spectated) {
        var path;
        if (spectated != null) {
          return action.resolve(spectated.object);
        }
        if (path = ((function() {
          try {
            return local.modules[name].require;
          } catch (_error) {}
        })())) {
          if (path[0] === '.') {
            path = normalize(local.dir + sep + path);
          }
          return action.resolve(require(path));
        }
        if (!local.upperCase(name)) {
          return action.resolve(require(name));
        }
        if (path = local.find(name)) {
          return action.resolve(require(path));
        }
        console.log('ipso: ' + ("warning: missing module " + name).yellow);
        return action.resolve({
          $ipso: {
            PENDING: true,
            module: name
          },
          $save: function(template) {
            if (template == null) {
              template = 'default';
            }
            return local.save(template, name, does);
          }
        });
      });
    }),
    loadModuleSync: function(name, does) {
      var path;
      try {
        return does.getSync({
          query: {
            tag: name
          }
        });
      } catch (_error) {}
      if (path = ((function() {
        try {
          return local.modules[name].require;
        } catch (_error) {}
      })())) {
        if (path[0] === '.') {
          path = normalize(local.dir + sep + path);
        }
        return require(path);
      }
      if (!local.upperCase(name)) {
        return require(name);
      }
      if (path = local.find(name)) {
        return require(path);
      }
      console.log('ipso: ' + ("warning: missing module " + name).yellow);
      return {
        $ipso: {
          PENDING: true,
          module: name
        },
        $save: function(template) {
          if (template == null) {
            template = 'default';
          }
          return local.save(template, name, does);
        }
      };
    }
  };
  return api = {
    loadModules: local.loadModules,
    loadModulesSync: local.loadModulesSync
  };
};
