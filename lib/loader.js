// Generated by CoffeeScript 1.6.3
var deferred, dirname, lastInstance, lstatSync, normalize, parallel, pipeline, readdirSync, sep, underscore, _ref, _ref1, _ref2;

_ref = require('also'), deferred = _ref.deferred, parallel = _ref.parallel, pipeline = _ref.pipeline;

_ref1 = require('path'), normalize = _ref1.normalize, sep = _ref1.sep, dirname = _ref1.dirname;

underscore = require('inflection').underscore;

_ref2 = require('fs'), readdirSync = _ref2.readdirSync, lstatSync = _ref2.lstatSync;

require('colors');

lastInstance = void 0;

module.exports._test = function() {
  return lastInstance;
};

module.exports.create = function(config) {
  var api, local;
  lastInstance = local = {
    dir: config.dir,
    modules: config.modules,
    upperCase: function(string) {
      var char, error;
      try {
        char = string[0].charCodeAt(0);
      } catch (_error) {
        error = _error;
        return false;
      }
      if (char > 64 && char < 91) {
        return true;
      }
      return false;
    },
    recurse: function(name, path, matches) {
      var fd, file, stat, _i, _len, _ref3, _results;
      _ref3 = readdirSync(path);
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        fd = _ref3[_i];
        file = path + sep + fd;
        stat = lstatSync(file);
        if (stat.isDirectory()) {
          local.recurse(name, file, matches);
          continue;
        }
        if (fd.match(new RegExp("^" + name + ".[js|coffee]"))) {
          _results.push(matches.push(dirname(file) + sep + name));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    find: function(name) {
      var matches;
      matches = [];
      try {
        local.recurse(underscore(name), local.dir + sep + 'lib', matches);
      } catch (_error) {}
      try {
        local.recurse(underscore(name), local.dir + sep + 'app', matches);
      } catch (_error) {}
      if (matches.length > 1) {
        throw new Error("ipso: found multiple matches for " + name + ", use ipso.modules");
      }
      return matches[0];
    },
    loadModule: deferred(function(action, name, does) {
      return does.get({
        query: {
          tag: name
        }
      }, function(error, spectated) {
        var path;
        if (spectated != null) {
          return action.resolve(spectated.object);
        }
        if (path = ((function() {
          try {
            return local.modules[name].require;
          } catch (_error) {}
        })())) {
          if (path[0] === '.') {
            path = normalize(local.dir + sep + path);
          }
          return action.resolve(require(path));
        }
        if (!local.upperCase(name)) {
          return action.resolve(require(name));
        }
        if (path = local.find(name)) {
          return action.resolve(require(path));
        }
        console.log('ipso: ' + ("warning: missing module " + name).yellow);
        return action.resolve({
          $ipso: {
            PENDING: true,
            module: name,
            save: function(path) {
              return console.log("\n#\n#   NonExistantModule.$ipso.save(templateTag, pa/th) \n#   ------------------------------------------------\n#   \n#   Not yet implemented.\n# \n#   * (for never having to write anything twice)\n#   * for cases where ipso detects the injection of a not yet existing module\n#   * can save the newly written stub to ./src/path/ as the \"\"first draft\"\" \n#   * templates from ~/.ipso/templates\n#   * pending `does` to expose access to expectations for a list of functions to create\n#                                                         -----------------------------\n# \n#   \n#             perhaps there's an even slicker way to do it?\n#  \n".green);
            }
          }
        });
      });
    }),
    loadModules: function(fnArgsArray, does) {
      var Module, promise;
      return promise = parallel((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = fnArgsArray.length; _i < _len; _i++) {
          Module = fnArgsArray[_i];
          _results.push((function(Module) {
            return function() {
              var nestedPromise;
              return nestedPromise = pipeline([
                function() {
                  return local.loadModule(Module, does);
                }, function(module) {
                  return does.spectate({
                    name: Module,
                    tagged: false
                  }, module);
                }
              ]);
            };
          })(Module));
        }
        return _results;
      })());
    }
  };
  return api = {
    loadModules: local.loadModules
  };
};
