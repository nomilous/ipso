// Generated by CoffeeScript 1.6.3
var AssertionError, Does, Loader, colors, config, deferred, does, facto, ipso, loadModules, loadModulesSync, parallel, should, util, _ref, _ref1;

_ref = require('also'), util = _ref.util, deferred = _ref.deferred, parallel = _ref.parallel;

AssertionError = require('assert').AssertionError;

facto = require('facto');

Loader = require('./loader');

colors = require('colors');

Does = require('does');

does = Does({
  does: {
    mode: 'spec'
  }
});

should = require('should');

config = {
  dir: process.cwd(),
  modules: {}
};

_ref1 = Loader.create(config), loadModules = _ref1.loadModules, loadModulesSync = _ref1.loadModulesSync;

module.exports = ipso = function(actualTestFunction) {
  var testFunctionForMocha;
  return testFunctionForMocha = function(done) {
    var Module, arg1, argsToInjectIntoTest, fnArgsArray, testResolver, _i, _len, _ref2,
      _this = this;
    fnArgsArray = util.argsOf(actualTestFunction);
    argsToInjectIntoTest = [];
    if (done == null) {
      if (fnArgsArray[0] === 'done' || fnArgsArray[0] === 'facto') {
        console.log('ipso cannot inject done into describe() or context()'.red);
        return;
      }
      does.activate({
        context: this,
        mode: 'spec',
        spec: null,
        resolver: null
      });
      _ref2 = loadModulesSync(fnArgsArray, does);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        Module = _ref2[_i];
        argsToInjectIntoTest.push(Module);
      }
      actualTestFunction.apply(this, argsToInjectIntoTest);
      return;
    }
    does.activate({
      context: this,
      mode: 'spec',
      spec: this.test,
      resolver: done
    });
    testResolver = function(metadata) {
      return does.assert(done).then(function(result) {
        if (fnArgsArray[0] === 'facto') {
          facto(metadata);
        }
        return done();
      }, function(error) {
        if (fnArgsArray[0] === 'facto') {
          return facto(metadata);
        }
      }, function(notify) {});
    };
    if (fnArgsArray[0] === 'done' || fnArgsArray[0] === 'facto') {
      argsToInjectIntoTest.push(testResolver);
      arg1 = fnArgsArray.shift();
    }
    return loadModules(fnArgsArray, does).then(function(Modules) {
      var error, promise, _j, _len1;
      for (_j = 0, _len1 = Modules.length; _j < _len1; _j++) {
        Module = Modules[_j];
        argsToInjectIntoTest.push(Module);
      }
      try {
        promise = actualTestFunction.apply(_this, argsToInjectIntoTest);
      } catch (_error) {
        error = _error;
        does.reset();
        done(error);
        return;
      }
      if (arg1 !== 'done' && arg1 !== 'facto') {
        testResolver();
      }
      if (promise.then != null) {
        return promise.then((function() {}), done);
      }
    }, done);
  };
};

ipso.modules = function(list) {
  var tag;
  for (tag in list) {
    if (list[tag].require == null) {
      throw new Error('ipso.module expects { tagName: { require: "path/or/name" } }');
    }
    config.modules[tag] = list[tag];
  }
  return ipso;
};

ipso.ipso = ipso;

ipso.mock = function(name) {
  var object;
  object = {
    title: name,
    is: function(mock) {
      if (typeof mock === 'object') {
        return object.should.equal(mock);
      }
      return name.should.equal(mock);
    }
  };
  return does.spectateSync({
    name: name,
    tagged: true
  }, object);
};

ipso.tag = deferred(function(action, list) {
  var tag;
  return parallel((function() {
    var _results;
    _results = [];
    for (tag in list) {
      _results.push((function(tag) {
        return function() {
          return does.spectate({
            name: tag,
            tagged: true
          }, list[tag]);
        };
      })(tag));
    }
    return _results;
  })()).then(action.resolve, action.reject, action.notify);
});

module.exports.once = function(fn) {
  return (function(done) {
    return function() {
      if (done) {
        return;
      }
      done = true;
      return fn.apply(this, arguments);
    };
  })(false);
};
