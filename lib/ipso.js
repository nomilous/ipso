// Generated by CoffeeScript 1.6.3
var AssertionError, Does, Loader, colors, config, deferred, does, facto, fs, ipso, loadModules, loadModulesSync, lstatOverride, lstatSync, override, parallel, readFileSync, sep, should, statSync, util, _ref, _ref1;

_ref = require('also'), util = _ref.util, deferred = _ref.deferred, parallel = _ref.parallel;

sep = require('path').sep;

AssertionError = require('assert').AssertionError;

facto = require('facto');

Loader = require('./loader');

colors = require('colors');

Does = require('does');

does = Does({
  does: {
    mode: 'spec'
  }
});

should = require('should');

config = {
  dir: process.cwd(),
  modules: {}
};

_ref1 = Loader.create(config), loadModules = _ref1.loadModules, loadModulesSync = _ref1.loadModulesSync;

module.exports = ipso = function(actualTestFunction) {
  var testFunctionForMocha;
  return testFunctionForMocha = function(done) {
    var Module, arg1, argsToInjectIntoTest, fnArgsArray, testResolver, _i, _len, _ref2,
      _this = this;
    fnArgsArray = util.argsOf(actualTestFunction);
    argsToInjectIntoTest = [];
    if (done == null) {
      if (fnArgsArray[0] === 'done' || fnArgsArray[0] === 'facto') {
        console.log('ipso cannot inject done into describe() or context()'.red);
        return;
      }
      does.activate({
        context: this,
        mode: 'spec',
        spec: null,
        resolver: null
      });
      _ref2 = loadModulesSync(fnArgsArray, does);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        Module = _ref2[_i];
        argsToInjectIntoTest.push(Module);
      }
      actualTestFunction.apply(this, argsToInjectIntoTest);
      return;
    }
    does.activate({
      context: this,
      mode: 'spec',
      spec: this.test,
      resolver: done
    });
    testResolver = function(metadata) {
      return does.assert(done).then(function(result) {
        if (fnArgsArray[0] === 'facto') {
          facto(metadata);
        }
        return done();
      }, function(error) {
        if (fnArgsArray[0] === 'facto') {
          return facto(metadata);
        }
      }, function(notify) {});
    };
    if (fnArgsArray[0] === 'done' || fnArgsArray[0] === 'facto') {
      argsToInjectIntoTest.push(testResolver);
      arg1 = fnArgsArray.shift();
    }
    return loadModules(fnArgsArray, does).then(function(Modules) {
      var error, promise, _j, _len1;
      for (_j = 0, _len1 = Modules.length; _j < _len1; _j++) {
        Module = Modules[_j];
        argsToInjectIntoTest.push(Module);
      }
      try {
        promise = actualTestFunction.apply(_this, argsToInjectIntoTest);
      } catch (_error) {
        error = _error;
        does.reset().then(function() {
          return done(error);
        });
        return;
      }
      if (arg1 !== 'done' && arg1 !== 'facto') {
        try {
          if ((promise.then != null) && _this.test.type === 'test') {
            return does.reset().then(function() {
              return done(new Error('Synchronous test returned promise. Inject test resolver (done or facto).'));
            });
          }
        } catch (_error) {}
        testResolver();
        return;
      }
      try {
        if (promise.then != null) {
          return promise.then((function() {}), function(error) {
            return does.reset().then(function() {
              return done(error);
            });
          });
        }
      } catch (_error) {}
    }, function(error) {
      return does.reset().then(function() {
        return done(error);
      });
    });
  };
};

ipso.ipso = ipso;

ipso.mock = function(name) {
  var object;
  object = {
    title: name,
    is: function(mock) {
      if (typeof mock === 'object') {
        return object.should.equal(mock);
      }
      return name.should.equal(mock);
    },
    "with": function(list) {
      var key;
      for (key in list) {
        object[key] = list[key];
      }
      return object;
    }
  };
  return does.spectateSync({
    name: name,
    tagged: true
  }, object);
};

ipso.tag = deferred(function(action, list) {
  var tag;
  return parallel((function() {
    var _results;
    _results = [];
    for (tag in list) {
      _results.push((function(tag) {
        return function() {
          return does.spectateSync({
            name: tag,
            tagged: true
          }, list[tag]);
        };
      })(tag));
    }
    return _results;
  })()).then(action.resolve, action.reject, action.notify);
});

override = {};

lstatOverride = {};

fs = require('fs');

readFileSync = fs.readFileSync;

fs.readFileSync = function(path, encoding) {
  var file, mod, modulePath, modulesPath, parts, scriptPath, _ref2;
  _ref2 = path.split(sep).slice(-2), mod = _ref2[0], file = _ref2[1];
  parts = path.split(sep).slice(0, -2);
  modulesPath = parts.join(sep);
  modulePath = parts.concat([mod]).join(sep);
  scriptPath = parts.concat([mod, 'STUBBED.js']).join(sep);
  if (override.hasOwnProperty(mod)) {
    switch (file) {
      case 'package.json':
        lstatOverride[modulesPath] = 1;
        lstatOverride[modulePath] = 1;
        lstatOverride[scriptPath] = 1;
        return JSON.stringify(override[mod]['package.json']);
      case 'STUBBED.js':
        return "module.exports = " + (override[mod]['STUBBED.js'].toString());
    }
  }
  return readFileSync(path, encoding);
};

statSync = fs.statSync;

fs.statSync = function(path) {
  if (path.match(/STUBBED.js/)) {
    return {
      isDirectory: function() {
        return false;
      }
    };
  }
  return statSync(path);
};

lstatSync = fs.lstatSync;

fs.lstatSync = function(path) {
  if (lstatOverride[path] != null) {
    return {
      isSymbolicLink: function() {
        return false;
      }
    };
  }
  return lstatSync(path);
};

ipso.def = function(list) {
  var moduleName, _results;
  _results = [];
  for (moduleName in list) {
    _results.push(override[moduleName] = {
      'package.json': {
        name: moduleName,
        version: '0.0.0',
        main: 'STUBBED.js',
        dependencies: {}
      },
      'STUBBED.js': list[moduleName].toString()
    });
  }
  return _results;
};

ipso.does = does;

module.exports.once = function(fn) {
  return (function(done) {
    return function() {
      if (done) {
        return;
      }
      done = true;
      return fn.apply(this, arguments);
    };
  })(false);
};
